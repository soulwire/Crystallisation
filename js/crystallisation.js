// Generated by CoffeeScript 1.4.0
var Line, Polygon, Vertex, crystallisation, gui,
  __slice = [].slice;

Vertex = (function() {

  function Vertex(x, y) {
    this.x = x != null ? x : 0.0;
    this.y = y != null ? y : 0.0;
  }

  Vertex.prototype.distanceSq = function(v) {
    var dx, dy;
    return (dx = v.x - this.x) * dx + (dy = v.y - this.y) * dy;
  };

  Vertex.prototype.distance = function(v) {
    var dx, dy;
    return sqrt((dx = v.x - this.x) * dx + (dy = v.y - this.y) * dy);
  };

  Vertex.prototype.angle = function(v) {
    return atan2(v.y - this.y, v.x - this.x);
  };

  Vertex.prototype.lerp = function(v, f) {
    return new Vertex(this.x + (v.x - this.x) * f, this.y + (v.y - this.y) * f);
  };

  Vertex.prototype.clone = function() {
    return new Vertex(this.x, this.y);
  };

  return Vertex;

})();

Line = (function() {

  function Line(start, end) {
    this.start = start;
    this.end = end;
  }

  return Line;

})();

Polygon = (function() {

  function Polygon() {
    var vertices;
    vertices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.vertices = vertices;
    this.generation = 0;
    this.unique = [];
  }

  Polygon.prototype.subdivide = function(randomness, opposite) {
    var i1, i2, j1, j2, l1, l2, nv, p1, p2, v1, v2, _ref;
    if (randomness == null) {
      randomness = 0.0;
    }
    if (opposite == null) {
      opposite = 0.5;
    }
    nv = this.vertices.length;
    i1 = ~~random(nv);
    i2 = random() < opposite ? ~~(i1 + nv / 2) % nv : ~~random(nv);
    while (i2 === i1) {
      i2 = ~~random(nv);
    }
    l1 = 0.5 + random(randomness * -0.5, randomness * 0.5);
    l2 = 0.5 + random(randomness * -0.5, randomness * 0.5);
    v1 = this.vertices[i1].lerp(this.vertices[(i1 + 1) % nv], l1);
    v2 = this.vertices[i2].lerp(this.vertices[(i2 + 1) % nv], l2);
    _ref = [i1, i2], j1 = _ref[0], j2 = _ref[1];
    p1 = new Polygon(v1);
    while (j1 !== i2) {
      p1.vertices.push(this.vertices[j1 = (j1 + 1) % nv]);
    }
    p1.vertices.push(v2);
    p2 = new Polygon(v2);
    while (j2 !== i1) {
      p2.vertices.push(this.vertices[j2 = (j2 + 1) % nv]);
    }
    p2.vertices.push(v1);
    p1.generation = this.generation + 1;
    p2.generation = this.generation + 1;
    p1.unique.push(new Line(v1, v2));
    return [p1, p2];
  };

  Polygon.prototype.centroid = function() {
    var cx, cy, vertex, _i, _len, _ref;
    cx = cy = 0.0;
    _ref = this.vertices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      vertex = _ref[_i];
      cx += vertex.x;
      cy += vertex.y;
    }
    return new Vertex(cx / this.vertices.length, cy / this.vertices.length);
  };

  Polygon.prototype.minAngle = function() {
    var A, B, C, a, b, c, index, len, next, prev, rule, val, vertex, _i, _len, _ref;
    rule = function(a, b, c) {
      return Math.acos((a * a + b * b - c * c) / (2 * a * b));
    };
    val = Number.MAX_VALUE;
    len = this.vertices.length;
    _ref = this.vertices;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      vertex = _ref[index];
      prev = this.vertices[(index - 1 + len) % len];
      next = this.vertices[(index + 1 + len) % len];
      a = prev.distance(vertex);
      b = next.distance(vertex);
      c = next.distance(prev);
      A = rule(b, c, a);
      B = rule(c, a, b);
      C = Math.PI - A - B;
      val = min(val, C);
    }
    return val;
  };

  Polygon.prototype.minSide = function() {
    var prev, side, vertex, _i, _len, _ref;
    side = Number.MAX_VALUE;
    prev = this.vertices[this.vertices.length - 1];
    _ref = this.vertices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      vertex = _ref[_i];
      side = min(side, vertex.distanceSq(prev));
      prev = vertex;
    }
    return sqrt(side);
  };

  Polygon.prototype.perimeter = function() {
    var result;
    result = this.vertices[0].distance(this.vertices[this.vertices.length - 1]);
    this.vertices.reduce(function(a, b) {
      result += a.distance(b);
      return a = b;
    });
    return result;
  };

  Polygon.prototype.draw = function(ctx) {
    var vertex, _i, _len, _ref;
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    vertex = this.vertices[0];
    ctx.moveTo(vertex.x, vertex.y);
    _ref = this.vertices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      vertex = _ref[_i];
      ctx.lineTo(vertex.x, vertex.y);
    }
    ctx.closePath();
    ctx.fill();
    return ctx.stroke();
  };

  return Polygon;

})();

crystallisation = Sketch.create({
  settings: {
    iterations: 50,
    randomness: 0.25,
    opposite: 0.1,
    minAngle: 0.4,
    minSide: 2
  },
  polygons: [],
  lines: [],
  container: document.getElementById('container'),
  autoclear: false,
  interval: 1,
  setup: function() {
    return this.reset();
  },
  step: function() {
    var drop, index, line, slice, slices, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
    index = ~~random(this.polygons.length - 1);
    slices = this.polygons[index].subdivide(this.settings.randomness, this.settings.opposite);
    for (_i = 0, _len = slices.length; _i < _len; _i++) {
      slice = slices[_i];
      if (slice.minAngle() < this.settings.minAngle) {
        drop = true;
        break;
      }
    }
    for (_j = 0, _len1 = slices.length; _j < _len1; _j++) {
      slice = slices[_j];
      if (slice.minSide() < this.settings.minSide) {
        drop = true;
        break;
      }
    }
    if (!(drop != null)) {
      _ref = this.polygons[index].unique;
      for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
        line = _ref[_k];
        this.lines.push(line);
      }
      for (_l = 0, _len3 = slices.length; _l < _len3; _l++) {
        slice = slices[_l];
        this.polygons.push(slice);
        slice.draw(this);
      }
      return this.polygons.splice(index, 1);
    }
  },
  reset: function() {
    var a, b, c, d;
    a = new Vertex(0, 0);
    b = new Vertex(this.width, 0);
    c = new Vertex(this.width, this.height);
    d = new Vertex(0, this.height);
    this.polygons = [new Polygon(a, b, c, d)];
    this.lines = [];
    return this.clear();
  },
  toggle: function() {
    return (this.running ? this.stop : this.start)();
  },
  draw: function() {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = this.settings.iterations; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(this.step());
    }
    return _results;
  },
  save: function() {
    return window.open(this.canvas.toDataURL(), 'subdivide', "top=20,left=20,width=" + this.width + ",height=" + this.height);
  }
});

gui = new dat.GUI();

gui.add(crystallisation.settings, 'minSide').min(0).max(100).name('min side length');

gui.add(crystallisation.settings, 'minAngle').min(0.0).max(1.2).step(0.01).name('min angle (rad)');

gui.add(crystallisation.settings, 'iterations').min(1).max(100);

gui.add(crystallisation.settings, 'randomness').min(0.0).max(1.0).step(0.01);

gui.add(crystallisation.settings, 'opposite').min(0.0).max(1.0).step(0.01).name('opposite sides');

gui.add(crystallisation, 'toggle').name('start / stop');

gui.add(crystallisation, 'reset').name('reset polygons');

gui.add(crystallisation, 'clear').name('clear canvas');

gui.add(crystallisation, 'save').name('save');
